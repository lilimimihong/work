# TODO List 项目说明文档

## 1. 技术选型
- **编程语言**：TypeScript，理由：错误提醒更早更细致，代码更清晰，强大的编辑器支持，能提供智能提示、自动补全和重构功能  
- **框架/库**：vue3，理由：组件化方便，利于扩展。
-              element-plus/resolvers: 自动按需引入 Element Plus 的组件。
- **数据库/存储**：浏览器本地存储，理由：离线访问，提升加载速度，减轻服务器压力，数据持久化。  
- 为什么不用 MongoDB：这是后端数据库，不适合前端直接用。
-  为什么不用本地文件：浏览器无法直接读写用户电脑上的任意文件，

## 2. 项目结构设计
- 整体架构说明:纯前端架构。所有业务逻辑、页面渲染及数据存储均在客户端完成，无需后端服务器支持。系统利用浏览器自带的 LocalStorage 实现数据的持久化存储，采用 MVVM 设计模式进行开发 
- 目录结构：  
  ```
  src/
  ├── api/              # API 接口层
  ├── assets/           # 静态资源文件
  ├── components/       # 公共组件
  ├── composables/      # 组合式函数 (Composition API)
  ├── router/           # 路由配置
  ├── stores/           # 状态管理 (Pinia / Vuex)
  ├── styleAll/         # 全局样式
  ├── utils/            # 工具函数
  └── views/            # 页面视图
  


  ```  
  

## 3. 需求细节与决策
- 描述是否必填？如何处理空输入？
描述为非必填，我这里直接给个默认值，自动选择学习，排序自动填充为0
- 已完成的任务在 UI 或 CLI 中如何显示？
系统通过 status 字段驱动视图渲染。
待办视图：自动过滤并隐藏 status: completed 的条目。
归档视图：已完成任务通过绿色 Tag 标识，并锁定“完成”操作，支持状态回滚。

- 任务排序逻辑（默认按创建时间，用户可选按优先级）。
按照添加的顺序排序

- 如果涉及扩展功能（例如同步/提醒），简述设计思路。  

## 4. AI 使用说明
- 是否使用 AI 工具？（ChatGPT / Copilot / Cursor / 其他）
智谱清言，gemini
- 使用 AI 的环节：  
  - 提供解决思路  
  - Bug 定位  
  - 文档初稿编写  
    

## 5. 运行与测试方式
- 本地运行方式：
npm install
npm run dev
- 已测试过的环境:
node 20
- 已知问题与不足：
  排序应该按数字大小排序，应该有创建时间

## 6. 总结与反思
- 如果有更多时间，你会如何改进？
-  修改排序，添加创建时间，完成时间的选项
- 你觉得这个实现的最大亮点是什么？
- 基于 Composition API 的“无后端”数据层封装：
利用Vue3的 Composition API，将增删改查逻辑、数据持久化、状态管理封装为一个独立的useMenus。
  优势：
逻辑复用：任何页面只要引入 useMenus，就能立即获得操作数据的能力。
模拟数据库：在纯前端环境下，通过 TypeScript 接口 定义数据模型，利用数组操作模拟了数据库的查询与过滤功能。
低耦合：视图层只负责展示，逻辑层负责数据处理。如果要对接真正的后端 API，只需要修改 useMenus.ts 一个文件，所有 UI 页面都不需要改动。
- 基于 Computed 的“响应式”视图驱动：
  在实现“点击完成 -> 列表自动消失”以及“分类筛选”功能时，利用了 Vue 的计算属性。
声明式编程：只需要定义“什么是‘学习’列表”（即：filter(category == '学习')），而不需要关心数据何时变化。
自动依赖追踪：当底层的 allMenus 数据发生变化，Vue 会自动重新计算 activeMenus 或 studyList，并精准更新 DOM。
性能优化：computed 具有缓存特性，只有当依赖的数据源变化时才会重新计算，比简单的函数调用更高效。
